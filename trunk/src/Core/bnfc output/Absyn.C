//C++ Abstract Syntax Implementation generated by the BNF Converter.
#include <algorithm>
#include "Absyn.H"

/********************   Main    ********************/
Main::Main(ListBlock *p1) { listblock_ = p1; }
Main::Main(const Main & other) {   listblock_ = other.listblock_->clone();

}
Main &Main::operator=(const Main & other) {
  Main tmp(other);
  swap(tmp);
  return *this;
}
void Main::swap(Main & other) {
  std::swap(listblock_, other.listblock_);

}

Main::~Main() { delete(listblock_); }

void Main::accept(Visitor *v) { v->visitMain(this); }
Main *Main::clone() const {
  return new Main(*this);
}

/********************   BFunc    ********************/
BFunc::BFunc(ListFunction *p1) { listfunction_ = p1; }
BFunc::BFunc(const BFunc & other) {   listfunction_ = other.listfunction_->clone();

}
BFunc &BFunc::operator=(const BFunc & other) {
  BFunc tmp(other);
  swap(tmp);
  return *this;
}
void BFunc::swap(BFunc & other) {
  std::swap(listfunction_, other.listfunction_);

}

BFunc::~BFunc() { delete(listfunction_); }

void BFunc::accept(Visitor *v) { v->visitBFunc(this); }
BFunc *BFunc::clone() const {
  return new BFunc(*this);
}

/********************   BStmt    ********************/
BStmt::BStmt(ListStatement *p1) { liststatement_ = p1; }
BStmt::BStmt(const BStmt & other) {   liststatement_ = other.liststatement_->clone();

}
BStmt &BStmt::operator=(const BStmt & other) {
  BStmt tmp(other);
  swap(tmp);
  return *this;
}
void BStmt::swap(BStmt & other) {
  std::swap(liststatement_, other.liststatement_);

}

BStmt::~BStmt() { delete(liststatement_); }

void BStmt::accept(Visitor *v) { v->visitBStmt(this); }
BStmt *BStmt::clone() const {
  return new BStmt(*this);
}

/********************   DTFunc    ********************/
DTFunc::DTFunc(Ident p1, ListParameter *p2, ListBlock *p3) { ident_ = p1; listparameter_ = p2; listblock_ = p3; }
DTFunc::DTFunc(const DTFunc & other) {   ident_ = other.ident_;
  listparameter_ = other.listparameter_->clone();
  listblock_ = other.listblock_->clone();

}
DTFunc &DTFunc::operator=(const DTFunc & other) {
  DTFunc tmp(other);
  swap(tmp);
  return *this;
}
void DTFunc::swap(DTFunc & other) {
  std::swap(ident_, other.ident_);
  std::swap(listparameter_, other.listparameter_);
  std::swap(listblock_, other.listblock_);

}

DTFunc::~DTFunc() { delete(listparameter_); delete(listblock_); }

void DTFunc::accept(Visitor *v) { v->visitDTFunc(this); }
DTFunc *DTFunc::clone() const {
  return new DTFunc(*this);
}

/********************   DTParam    ********************/
DTParam::DTParam(Ident p1) { ident_ = p1; }
DTParam::DTParam(const DTParam & other) {   ident_ = other.ident_;

}
DTParam &DTParam::operator=(const DTParam & other) {
  DTParam tmp(other);
  swap(tmp);
  return *this;
}
void DTParam::swap(DTParam & other) {
  std::swap(ident_, other.ident_);

}

DTParam::~DTParam() { }

void DTParam::accept(Visitor *v) { v->visitDTParam(this); }
DTParam *DTParam::clone() const {
  return new DTParam(*this);
}

/********************   ListBlock    ********************/
ListBlock::ListBlock(Block *p1, ListBlock *p2) { block_ = p1; listblock_ = p2; }
ListBlock::ListBlock(const ListBlock & other) {   block_ = other.block_->clone();
  listblock_ = other.listblock_->clone();

}
ListBlock &ListBlock::operator=(const ListBlock & other) {
  ListBlock tmp(other);
  swap(tmp);
  return *this;
}
void ListBlock::swap(ListBlock & other) {
  std::swap(block_, other.block_);
  std::swap(listblock_, other.listblock_);

}

ListBlock::~ListBlock() { delete(block_); delete(listblock_); }
ListBlock::ListBlock(Block *p)
{
  block_ = p;
  listblock_= 0;
}
ListBlock* ListBlock::reverse()
{
  if (listblock_ == 0) return this;
  else
  {
    ListBlock *tmp = listblock_->reverse(this);
    listblock_ = 0;
    return tmp;
  }
}

ListBlock* ListBlock::reverse(ListBlock* prev)
{
  if (listblock_ == 0)
  {
    listblock_ = prev;
    return this;
  }
  else
  {
    ListBlock *tmp = listblock_->reverse(this);
    listblock_ = prev;
    return tmp;
  }
}


void ListBlock::accept(Visitor *v) { v->visitListBlock(this); }
ListBlock *ListBlock::clone() const {
  return new ListBlock(*this);
}

/********************   ListFunction    ********************/
ListFunction::ListFunction(Function *p1, ListFunction *p2) { function_ = p1; listfunction_ = p2; }
ListFunction::ListFunction(const ListFunction & other) {   function_ = other.function_->clone();
  listfunction_ = other.listfunction_->clone();

}
ListFunction &ListFunction::operator=(const ListFunction & other) {
  ListFunction tmp(other);
  swap(tmp);
  return *this;
}
void ListFunction::swap(ListFunction & other) {
  std::swap(function_, other.function_);
  std::swap(listfunction_, other.listfunction_);

}

ListFunction::~ListFunction() { delete(function_); delete(listfunction_); }
ListFunction::ListFunction(Function *p)
{
  function_ = p;
  listfunction_= 0;
}
ListFunction* ListFunction::reverse()
{
  if (listfunction_ == 0) return this;
  else
  {
    ListFunction *tmp = listfunction_->reverse(this);
    listfunction_ = 0;
    return tmp;
  }
}

ListFunction* ListFunction::reverse(ListFunction* prev)
{
  if (listfunction_ == 0)
  {
    listfunction_ = prev;
    return this;
  }
  else
  {
    ListFunction *tmp = listfunction_->reverse(this);
    listfunction_ = prev;
    return tmp;
  }
}


void ListFunction::accept(Visitor *v) { v->visitListFunction(this); }
ListFunction *ListFunction::clone() const {
  return new ListFunction(*this);
}

/********************   ListStatement    ********************/
ListStatement::ListStatement(Statement *p1, ListStatement *p2) { statement_ = p1; liststatement_ = p2; }
ListStatement::ListStatement(const ListStatement & other) {   statement_ = other.statement_->clone();
  liststatement_ = other.liststatement_->clone();

}
ListStatement &ListStatement::operator=(const ListStatement & other) {
  ListStatement tmp(other);
  swap(tmp);
  return *this;
}
void ListStatement::swap(ListStatement & other) {
  std::swap(statement_, other.statement_);
  std::swap(liststatement_, other.liststatement_);

}

ListStatement::~ListStatement() { delete(statement_); delete(liststatement_); }
ListStatement::ListStatement(Statement *p)
{
  statement_ = p;
  liststatement_= 0;
}
ListStatement* ListStatement::reverse()
{
  if (liststatement_ == 0) return this;
  else
  {
    ListStatement *tmp = liststatement_->reverse(this);
    liststatement_ = 0;
    return tmp;
  }
}

ListStatement* ListStatement::reverse(ListStatement* prev)
{
  if (liststatement_ == 0)
  {
    liststatement_ = prev;
    return this;
  }
  else
  {
    ListStatement *tmp = liststatement_->reverse(this);
    liststatement_ = prev;
    return tmp;
  }
}


void ListStatement::accept(Visitor *v) { v->visitListStatement(this); }
ListStatement *ListStatement::clone() const {
  return new ListStatement(*this);
}

/********************   ListParameter    ********************/
ListParameter::ListParameter(Parameter *p1, ListParameter *p2) { parameter_ = p1; listparameter_ = p2; }
ListParameter::ListParameter(const ListParameter & other) {   parameter_ = other.parameter_->clone();
  listparameter_ = other.listparameter_->clone();

}
ListParameter &ListParameter::operator=(const ListParameter & other) {
  ListParameter tmp(other);
  swap(tmp);
  return *this;
}
void ListParameter::swap(ListParameter & other) {
  std::swap(parameter_, other.parameter_);
  std::swap(listparameter_, other.listparameter_);

}

ListParameter::~ListParameter() { delete(parameter_); delete(listparameter_); }
ListParameter::ListParameter(Parameter *p)
{
  parameter_ = p;
  listparameter_= 0;
}
ListParameter* ListParameter::reverse()
{
  if (listparameter_ == 0) return this;
  else
  {
    ListParameter *tmp = listparameter_->reverse(this);
    listparameter_ = 0;
    return tmp;
  }
}

ListParameter* ListParameter::reverse(ListParameter* prev)
{
  if (listparameter_ == 0)
  {
    listparameter_ = prev;
    return this;
  }
  else
  {
    ListParameter *tmp = listparameter_->reverse(this);
    listparameter_ = prev;
    return tmp;
  }
}


void ListParameter::accept(Visitor *v) { v->visitListParameter(this); }
ListParameter *ListParameter::clone() const {
  return new ListParameter(*this);
}

/********************   SExp    ********************/
SExp::SExp(Expression *p1) { expression_ = p1; }
SExp::SExp(const SExp & other) {   expression_ = other.expression_->clone();

}
SExp &SExp::operator=(const SExp & other) {
  SExp tmp(other);
  swap(tmp);
  return *this;
}
void SExp::swap(SExp & other) {
  std::swap(expression_, other.expression_);

}

SExp::~SExp() { delete(expression_); }

void SExp::accept(Visitor *v) { v->visitSExp(this); }
SExp *SExp::clone() const {
  return new SExp(*this);
}

/********************   SScope    ********************/
SScope::SScope(ListStatement *p1) { liststatement_ = p1; }
SScope::SScope(const SScope & other) {   liststatement_ = other.liststatement_->clone();

}
SScope &SScope::operator=(const SScope & other) {
  SScope tmp(other);
  swap(tmp);
  return *this;
}
void SScope::swap(SScope & other) {
  std::swap(liststatement_, other.liststatement_);

}

SScope::~SScope() { delete(liststatement_); }

void SScope::accept(Visitor *v) { v->visitSScope(this); }
SScope *SScope::clone() const {
  return new SScope(*this);
}

/********************   SRet    ********************/
SRet::SRet(Expression *p1) { expression_ = p1; }
SRet::SRet(const SRet & other) {   expression_ = other.expression_->clone();

}
SRet &SRet::operator=(const SRet & other) {
  SRet tmp(other);
  swap(tmp);
  return *this;
}
void SRet::swap(SRet & other) {
  std::swap(expression_, other.expression_);

}

SRet::~SRet() { delete(expression_); }

void SRet::accept(Visitor *v) { v->visitSRet(this); }
SRet *SRet::clone() const {
  return new SRet(*this);
}

/********************   SIf    ********************/
SIf::SIf(Expression *p1, ListStatement *p2) { expression_ = p1; liststatement_ = p2; }
SIf::SIf(const SIf & other) {   expression_ = other.expression_->clone();
  liststatement_ = other.liststatement_->clone();

}
SIf &SIf::operator=(const SIf & other) {
  SIf tmp(other);
  swap(tmp);
  return *this;
}
void SIf::swap(SIf & other) {
  std::swap(expression_, other.expression_);
  std::swap(liststatement_, other.liststatement_);

}

SIf::~SIf() { delete(expression_); delete(liststatement_); }

void SIf::accept(Visitor *v) { v->visitSIf(this); }
SIf *SIf::clone() const {
  return new SIf(*this);
}

/********************   SIfElse    ********************/
SIfElse::SIfElse(Expression *p1, ListStatement *p2, ListStatement *p3) { expression_ = p1; liststatement_1 = p2; liststatement_2 = p3; }
SIfElse::SIfElse(const SIfElse & other) {   expression_ = other.expression_->clone();
  liststatement_1 = other.liststatement_1->clone();
  liststatement_2 = other.liststatement_2->clone();

}
SIfElse &SIfElse::operator=(const SIfElse & other) {
  SIfElse tmp(other);
  swap(tmp);
  return *this;
}
void SIfElse::swap(SIfElse & other) {
  std::swap(expression_, other.expression_);
  std::swap(liststatement_1, other.liststatement_1);
  std::swap(liststatement_2, other.liststatement_2);

}

SIfElse::~SIfElse() { delete(expression_); delete(liststatement_1); delete(liststatement_2); }

void SIfElse::accept(Visitor *v) { v->visitSIfElse(this); }
SIfElse *SIfElse::clone() const {
  return new SIfElse(*this);
}

/********************   SWhile    ********************/
SWhile::SWhile(Expression *p1, ListStatement *p2) { expression_ = p1; liststatement_ = p2; }
SWhile::SWhile(const SWhile & other) {   expression_ = other.expression_->clone();
  liststatement_ = other.liststatement_->clone();

}
SWhile &SWhile::operator=(const SWhile & other) {
  SWhile tmp(other);
  swap(tmp);
  return *this;
}
void SWhile::swap(SWhile & other) {
  std::swap(expression_, other.expression_);
  std::swap(liststatement_, other.liststatement_);

}

SWhile::~SWhile() { delete(expression_); delete(liststatement_); }

void SWhile::accept(Visitor *v) { v->visitSWhile(this); }
SWhile *SWhile::clone() const {
  return new SWhile(*this);
}

/********************   SUntil    ********************/
SUntil::SUntil(Expression *p1, ListStatement *p2) { expression_ = p1; liststatement_ = p2; }
SUntil::SUntil(const SUntil & other) {   expression_ = other.expression_->clone();
  liststatement_ = other.liststatement_->clone();

}
SUntil &SUntil::operator=(const SUntil & other) {
  SUntil tmp(other);
  swap(tmp);
  return *this;
}
void SUntil::swap(SUntil & other) {
  std::swap(expression_, other.expression_);
  std::swap(liststatement_, other.liststatement_);

}

SUntil::~SUntil() { delete(expression_); delete(liststatement_); }

void SUntil::accept(Visitor *v) { v->visitSUntil(this); }
SUntil *SUntil::clone() const {
  return new SUntil(*this);
}

/********************   SFor    ********************/
SFor::SFor(ListExpression *p1, Expression *p2, ListExpression *p3, ListStatement *p4) { listexpression_1 = p1; expression_ = p2; listexpression_2 = p3; liststatement_ = p4; }
SFor::SFor(const SFor & other) {   listexpression_1 = other.listexpression_1->clone();
  expression_ = other.expression_->clone();
  listexpression_2 = other.listexpression_2->clone();
  liststatement_ = other.liststatement_->clone();

}
SFor &SFor::operator=(const SFor & other) {
  SFor tmp(other);
  swap(tmp);
  return *this;
}
void SFor::swap(SFor & other) {
  std::swap(listexpression_1, other.listexpression_1);
  std::swap(expression_, other.expression_);
  std::swap(listexpression_2, other.listexpression_2);
  std::swap(liststatement_, other.liststatement_);

}

SFor::~SFor() { delete(listexpression_1); delete(expression_); delete(listexpression_2); delete(liststatement_); }

void SFor::accept(Visitor *v) { v->visitSFor(this); }
SFor *SFor::clone() const {
  return new SFor(*this);
}

/********************   SBreak    ********************/
SBreak::SBreak() { }
SBreak::SBreak(const SBreak & other) { 
}
SBreak &SBreak::operator=(const SBreak & other) {
  SBreak tmp(other);
  swap(tmp);
  return *this;
}
void SBreak::swap(SBreak & other) {

}

SBreak::~SBreak() { }

void SBreak::accept(Visitor *v) { v->visitSBreak(this); }
SBreak *SBreak::clone() const {
  return new SBreak(*this);
}

/********************   SContinue    ********************/
SContinue::SContinue() { }
SContinue::SContinue(const SContinue & other) { 
}
SContinue &SContinue::operator=(const SContinue & other) {
  SContinue tmp(other);
  swap(tmp);
  return *this;
}
void SContinue::swap(SContinue & other) {

}

SContinue::~SContinue() { }

void SContinue::accept(Visitor *v) { v->visitSContinue(this); }
SContinue *SContinue::clone() const {
  return new SContinue(*this);
}

/********************   ECDbl    ********************/
ECDbl::ECDbl(Double p1) { double_ = p1; }
ECDbl::ECDbl(const ECDbl & other) {   double_ = other.double_;

}
ECDbl &ECDbl::operator=(const ECDbl & other) {
  ECDbl tmp(other);
  swap(tmp);
  return *this;
}
void ECDbl::swap(ECDbl & other) {
  std::swap(double_, other.double_);

}

ECDbl::~ECDbl() { }

void ECDbl::accept(Visitor *v) { v->visitECDbl(this); }
ECDbl *ECDbl::clone() const {
  return new ECDbl(*this);
}

/********************   ECInt    ********************/
ECInt::ECInt(Integer p1) { integer_ = p1; }
ECInt::ECInt(const ECInt & other) {   integer_ = other.integer_;

}
ECInt &ECInt::operator=(const ECInt & other) {
  ECInt tmp(other);
  swap(tmp);
  return *this;
}
void ECInt::swap(ECInt & other) {
  std::swap(integer_, other.integer_);

}

ECInt::~ECInt() { }

void ECInt::accept(Visitor *v) { v->visitECInt(this); }
ECInt *ECInt::clone() const {
  return new ECInt(*this);
}

/********************   EVar    ********************/
EVar::EVar(Ident p1) { ident_ = p1; }
EVar::EVar(const EVar & other) {   ident_ = other.ident_;

}
EVar &EVar::operator=(const EVar & other) {
  EVar tmp(other);
  swap(tmp);
  return *this;
}
void EVar::swap(EVar & other) {
  std::swap(ident_, other.ident_);

}

EVar::~EVar() { }

void EVar::accept(Visitor *v) { v->visitEVar(this); }
EVar *EVar::clone() const {
  return new EVar(*this);
}

/********************   EPi    ********************/
EPi::EPi() { }
EPi::EPi(const EPi & other) { 
}
EPi &EPi::operator=(const EPi & other) {
  EPi tmp(other);
  swap(tmp);
  return *this;
}
void EPi::swap(EPi & other) {

}

EPi::~EPi() { }

void EPi::accept(Visitor *v) { v->visitEPi(this); }
EPi *EPi::clone() const {
  return new EPi(*this);
}

/********************   ESimpleCall    ********************/
ESimpleCall::ESimpleCall(Ident p1) { ident_ = p1; }
ESimpleCall::ESimpleCall(const ESimpleCall & other) {   ident_ = other.ident_;

}
ESimpleCall &ESimpleCall::operator=(const ESimpleCall & other) {
  ESimpleCall tmp(other);
  swap(tmp);
  return *this;
}
void ESimpleCall::swap(ESimpleCall & other) {
  std::swap(ident_, other.ident_);

}

ESimpleCall::~ESimpleCall() { }

void ESimpleCall::accept(Visitor *v) { v->visitESimpleCall(this); }
ESimpleCall *ESimpleCall::clone() const {
  return new ESimpleCall(*this);
}

/********************   ECall    ********************/
ECall::ECall(Ident p1, ListExpression *p2) { ident_ = p1; listexpression_ = p2; }
ECall::ECall(const ECall & other) {   ident_ = other.ident_;
  listexpression_ = other.listexpression_->clone();

}
ECall &ECall::operator=(const ECall & other) {
  ECall tmp(other);
  swap(tmp);
  return *this;
}
void ECall::swap(ECall & other) {
  std::swap(ident_, other.ident_);
  std::swap(listexpression_, other.listexpression_);

}

ECall::~ECall() { delete(listexpression_); }

void ECall::accept(Visitor *v) { v->visitECall(this); }
ECall *ECall::clone() const {
  return new ECall(*this);
}

/********************   EPostInc    ********************/
EPostInc::EPostInc(Ident p1) { ident_ = p1; }
EPostInc::EPostInc(const EPostInc & other) {   ident_ = other.ident_;

}
EPostInc &EPostInc::operator=(const EPostInc & other) {
  EPostInc tmp(other);
  swap(tmp);
  return *this;
}
void EPostInc::swap(EPostInc & other) {
  std::swap(ident_, other.ident_);

}

EPostInc::~EPostInc() { }

void EPostInc::accept(Visitor *v) { v->visitEPostInc(this); }
EPostInc *EPostInc::clone() const {
  return new EPostInc(*this);
}

/********************   EPostDec    ********************/
EPostDec::EPostDec(Ident p1) { ident_ = p1; }
EPostDec::EPostDec(const EPostDec & other) {   ident_ = other.ident_;

}
EPostDec &EPostDec::operator=(const EPostDec & other) {
  EPostDec tmp(other);
  swap(tmp);
  return *this;
}
void EPostDec::swap(EPostDec & other) {
  std::swap(ident_, other.ident_);

}

EPostDec::~EPostDec() { }

void EPostDec::accept(Visitor *v) { v->visitEPostDec(this); }
EPostDec *EPostDec::clone() const {
  return new EPostDec(*this);
}

/********************   EAbs    ********************/
EAbs::EAbs(Expression *p1) { expression_ = p1; }
EAbs::EAbs(const EAbs & other) {   expression_ = other.expression_->clone();

}
EAbs &EAbs::operator=(const EAbs & other) {
  EAbs tmp(other);
  swap(tmp);
  return *this;
}
void EAbs::swap(EAbs & other) {
  std::swap(expression_, other.expression_);

}

EAbs::~EAbs() { delete(expression_); }

void EAbs::accept(Visitor *v) { v->visitEAbs(this); }
EAbs *EAbs::clone() const {
  return new EAbs(*this);
}

/********************   EPow    ********************/
EPow::EPow(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EPow::EPow(const EPow & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EPow &EPow::operator=(const EPow & other) {
  EPow tmp(other);
  swap(tmp);
  return *this;
}
void EPow::swap(EPow & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EPow::~EPow() { delete(expression_1); delete(expression_2); }

void EPow::accept(Visitor *v) { v->visitEPow(this); }
EPow *EPow::clone() const {
  return new EPow(*this);
}

/********************   ESqrt    ********************/
ESqrt::ESqrt(Expression *p1) { expression_ = p1; }
ESqrt::ESqrt(const ESqrt & other) {   expression_ = other.expression_->clone();

}
ESqrt &ESqrt::operator=(const ESqrt & other) {
  ESqrt tmp(other);
  swap(tmp);
  return *this;
}
void ESqrt::swap(ESqrt & other) {
  std::swap(expression_, other.expression_);

}

ESqrt::~ESqrt() { delete(expression_); }

void ESqrt::accept(Visitor *v) { v->visitESqrt(this); }
ESqrt *ESqrt::clone() const {
  return new ESqrt(*this);
}

/********************   EExp    ********************/
EExp::EExp(Expression *p1) { expression_ = p1; }
EExp::EExp(const EExp & other) {   expression_ = other.expression_->clone();

}
EExp &EExp::operator=(const EExp & other) {
  EExp tmp(other);
  swap(tmp);
  return *this;
}
void EExp::swap(EExp & other) {
  std::swap(expression_, other.expression_);

}

EExp::~EExp() { delete(expression_); }

void EExp::accept(Visitor *v) { v->visitEExp(this); }
EExp *EExp::clone() const {
  return new EExp(*this);
}

/********************   ELog    ********************/
ELog::ELog(Expression *p1) { expression_ = p1; }
ELog::ELog(const ELog & other) {   expression_ = other.expression_->clone();

}
ELog &ELog::operator=(const ELog & other) {
  ELog tmp(other);
  swap(tmp);
  return *this;
}
void ELog::swap(ELog & other) {
  std::swap(expression_, other.expression_);

}

ELog::~ELog() { delete(expression_); }

void ELog::accept(Visitor *v) { v->visitELog(this); }
ELog *ELog::clone() const {
  return new ELog(*this);
}

/********************   ELogD    ********************/
ELogD::ELogD(Expression *p1) { expression_ = p1; }
ELogD::ELogD(const ELogD & other) {   expression_ = other.expression_->clone();

}
ELogD &ELogD::operator=(const ELogD & other) {
  ELogD tmp(other);
  swap(tmp);
  return *this;
}
void ELogD::swap(ELogD & other) {
  std::swap(expression_, other.expression_);

}

ELogD::~ELogD() { delete(expression_); }

void ELogD::accept(Visitor *v) { v->visitELogD(this); }
ELogD *ELogD::clone() const {
  return new ELogD(*this);
}

/********************   ESin    ********************/
ESin::ESin(Expression *p1) { expression_ = p1; }
ESin::ESin(const ESin & other) {   expression_ = other.expression_->clone();

}
ESin &ESin::operator=(const ESin & other) {
  ESin tmp(other);
  swap(tmp);
  return *this;
}
void ESin::swap(ESin & other) {
  std::swap(expression_, other.expression_);

}

ESin::~ESin() { delete(expression_); }

void ESin::accept(Visitor *v) { v->visitESin(this); }
ESin *ESin::clone() const {
  return new ESin(*this);
}

/********************   ECos    ********************/
ECos::ECos(Expression *p1) { expression_ = p1; }
ECos::ECos(const ECos & other) {   expression_ = other.expression_->clone();

}
ECos &ECos::operator=(const ECos & other) {
  ECos tmp(other);
  swap(tmp);
  return *this;
}
void ECos::swap(ECos & other) {
  std::swap(expression_, other.expression_);

}

ECos::~ECos() { delete(expression_); }

void ECos::accept(Visitor *v) { v->visitECos(this); }
ECos *ECos::clone() const {
  return new ECos(*this);
}

/********************   ETan    ********************/
ETan::ETan(Expression *p1) { expression_ = p1; }
ETan::ETan(const ETan & other) {   expression_ = other.expression_->clone();

}
ETan &ETan::operator=(const ETan & other) {
  ETan tmp(other);
  swap(tmp);
  return *this;
}
void ETan::swap(ETan & other) {
  std::swap(expression_, other.expression_);

}

ETan::~ETan() { delete(expression_); }

void ETan::accept(Visitor *v) { v->visitETan(this); }
ETan *ETan::clone() const {
  return new ETan(*this);
}

/********************   EAtan    ********************/
EAtan::EAtan(Expression *p1) { expression_ = p1; }
EAtan::EAtan(const EAtan & other) {   expression_ = other.expression_->clone();

}
EAtan &EAtan::operator=(const EAtan & other) {
  EAtan tmp(other);
  swap(tmp);
  return *this;
}
void EAtan::swap(EAtan & other) {
  std::swap(expression_, other.expression_);

}

EAtan::~EAtan() { delete(expression_); }

void EAtan::accept(Visitor *v) { v->visitEAtan(this); }
EAtan *EAtan::clone() const {
  return new EAtan(*this);
}

/********************   EAtanT    ********************/
EAtanT::EAtanT(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EAtanT::EAtanT(const EAtanT & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EAtanT &EAtanT::operator=(const EAtanT & other) {
  EAtanT tmp(other);
  swap(tmp);
  return *this;
}
void EAtanT::swap(EAtanT & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EAtanT::~EAtanT() { delete(expression_1); delete(expression_2); }

void EAtanT::accept(Visitor *v) { v->visitEAtanT(this); }
EAtanT *EAtanT::clone() const {
  return new EAtanT(*this);
}

/********************   EAsin    ********************/
EAsin::EAsin(Expression *p1) { expression_ = p1; }
EAsin::EAsin(const EAsin & other) {   expression_ = other.expression_->clone();

}
EAsin &EAsin::operator=(const EAsin & other) {
  EAsin tmp(other);
  swap(tmp);
  return *this;
}
void EAsin::swap(EAsin & other) {
  std::swap(expression_, other.expression_);

}

EAsin::~EAsin() { delete(expression_); }

void EAsin::accept(Visitor *v) { v->visitEAsin(this); }
EAsin *EAsin::clone() const {
  return new EAsin(*this);
}

/********************   EAcos    ********************/
EAcos::EAcos(Expression *p1) { expression_ = p1; }
EAcos::EAcos(const EAcos & other) {   expression_ = other.expression_->clone();

}
EAcos &EAcos::operator=(const EAcos & other) {
  EAcos tmp(other);
  swap(tmp);
  return *this;
}
void EAcos::swap(EAcos & other) {
  std::swap(expression_, other.expression_);

}

EAcos::~EAcos() { delete(expression_); }

void EAcos::accept(Visitor *v) { v->visitEAcos(this); }
EAcos *EAcos::clone() const {
  return new EAcos(*this);
}

/********************   ELnot    ********************/
ELnot::ELnot(Expression *p1) { expression_ = p1; }
ELnot::ELnot(const ELnot & other) {   expression_ = other.expression_->clone();

}
ELnot &ELnot::operator=(const ELnot & other) {
  ELnot tmp(other);
  swap(tmp);
  return *this;
}
void ELnot::swap(ELnot & other) {
  std::swap(expression_, other.expression_);

}

ELnot::~ELnot() { delete(expression_); }

void ELnot::accept(Visitor *v) { v->visitELnot(this); }
ELnot *ELnot::clone() const {
  return new ELnot(*this);
}

/********************   EPreInc    ********************/
EPreInc::EPreInc(Ident p1) { ident_ = p1; }
EPreInc::EPreInc(const EPreInc & other) {   ident_ = other.ident_;

}
EPreInc &EPreInc::operator=(const EPreInc & other) {
  EPreInc tmp(other);
  swap(tmp);
  return *this;
}
void EPreInc::swap(EPreInc & other) {
  std::swap(ident_, other.ident_);

}

EPreInc::~EPreInc() { }

void EPreInc::accept(Visitor *v) { v->visitEPreInc(this); }
EPreInc *EPreInc::clone() const {
  return new EPreInc(*this);
}

/********************   EPreDec    ********************/
EPreDec::EPreDec(Ident p1) { ident_ = p1; }
EPreDec::EPreDec(const EPreDec & other) {   ident_ = other.ident_;

}
EPreDec &EPreDec::operator=(const EPreDec & other) {
  EPreDec tmp(other);
  swap(tmp);
  return *this;
}
void EPreDec::swap(EPreDec & other) {
  std::swap(ident_, other.ident_);

}

EPreDec::~EPreDec() { }

void EPreDec::accept(Visitor *v) { v->visitEPreDec(this); }
EPreDec *EPreDec::clone() const {
  return new EPreDec(*this);
}

/********************   ENeg    ********************/
ENeg::ENeg(Expression *p1) { expression_ = p1; }
ENeg::ENeg(const ENeg & other) {   expression_ = other.expression_->clone();

}
ENeg &ENeg::operator=(const ENeg & other) {
  ENeg tmp(other);
  swap(tmp);
  return *this;
}
void ENeg::swap(ENeg & other) {
  std::swap(expression_, other.expression_);

}

ENeg::~ENeg() { delete(expression_); }

void ENeg::accept(Visitor *v) { v->visitENeg(this); }
ENeg *ENeg::clone() const {
  return new ENeg(*this);
}

/********************   EBnot    ********************/
EBnot::EBnot(Expression *p1) { expression_ = p1; }
EBnot::EBnot(const EBnot & other) {   expression_ = other.expression_->clone();

}
EBnot &EBnot::operator=(const EBnot & other) {
  EBnot tmp(other);
  swap(tmp);
  return *this;
}
void EBnot::swap(EBnot & other) {
  std::swap(expression_, other.expression_);

}

EBnot::~EBnot() { delete(expression_); }

void EBnot::accept(Visitor *v) { v->visitEBnot(this); }
EBnot *EBnot::clone() const {
  return new EBnot(*this);
}

/********************   EPos    ********************/
EPos::EPos(Expression *p1) { expression_ = p1; }
EPos::EPos(const EPos & other) {   expression_ = other.expression_->clone();

}
EPos &EPos::operator=(const EPos & other) {
  EPos tmp(other);
  swap(tmp);
  return *this;
}
void EPos::swap(EPos & other) {
  std::swap(expression_, other.expression_);

}

EPos::~EPos() { delete(expression_); }

void EPos::accept(Visitor *v) { v->visitEPos(this); }
EPos *EPos::clone() const {
  return new EPos(*this);
}

/********************   EMul    ********************/
EMul::EMul(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EMul::EMul(const EMul & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EMul &EMul::operator=(const EMul & other) {
  EMul tmp(other);
  swap(tmp);
  return *this;
}
void EMul::swap(EMul & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EMul::~EMul() { delete(expression_1); delete(expression_2); }

void EMul::accept(Visitor *v) { v->visitEMul(this); }
EMul *EMul::clone() const {
  return new EMul(*this);
}

/********************   EDiv    ********************/
EDiv::EDiv(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EDiv::EDiv(const EDiv & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EDiv &EDiv::operator=(const EDiv & other) {
  EDiv tmp(other);
  swap(tmp);
  return *this;
}
void EDiv::swap(EDiv & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EDiv::~EDiv() { delete(expression_1); delete(expression_2); }

void EDiv::accept(Visitor *v) { v->visitEDiv(this); }
EDiv *EDiv::clone() const {
  return new EDiv(*this);
}

/********************   EMod    ********************/
EMod::EMod(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EMod::EMod(const EMod & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EMod &EMod::operator=(const EMod & other) {
  EMod tmp(other);
  swap(tmp);
  return *this;
}
void EMod::swap(EMod & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EMod::~EMod() { delete(expression_1); delete(expression_2); }

void EMod::accept(Visitor *v) { v->visitEMod(this); }
EMod *EMod::clone() const {
  return new EMod(*this);
}

/********************   EAdd    ********************/
EAdd::EAdd(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EAdd::EAdd(const EAdd & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EAdd &EAdd::operator=(const EAdd & other) {
  EAdd tmp(other);
  swap(tmp);
  return *this;
}
void EAdd::swap(EAdd & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EAdd::~EAdd() { delete(expression_1); delete(expression_2); }

void EAdd::accept(Visitor *v) { v->visitEAdd(this); }
EAdd *EAdd::clone() const {
  return new EAdd(*this);
}

/********************   ESub    ********************/
ESub::ESub(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
ESub::ESub(const ESub & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
ESub &ESub::operator=(const ESub & other) {
  ESub tmp(other);
  swap(tmp);
  return *this;
}
void ESub::swap(ESub & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

ESub::~ESub() { delete(expression_1); delete(expression_2); }

void ESub::accept(Visitor *v) { v->visitESub(this); }
ESub *ESub::clone() const {
  return new ESub(*this);
}

/********************   ELSh    ********************/
ELSh::ELSh(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
ELSh::ELSh(const ELSh & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
ELSh &ELSh::operator=(const ELSh & other) {
  ELSh tmp(other);
  swap(tmp);
  return *this;
}
void ELSh::swap(ELSh & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

ELSh::~ELSh() { delete(expression_1); delete(expression_2); }

void ELSh::accept(Visitor *v) { v->visitELSh(this); }
ELSh *ELSh::clone() const {
  return new ELSh(*this);
}

/********************   ERSh    ********************/
ERSh::ERSh(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
ERSh::ERSh(const ERSh & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
ERSh &ERSh::operator=(const ERSh & other) {
  ERSh tmp(other);
  swap(tmp);
  return *this;
}
void ERSh::swap(ERSh & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

ERSh::~ERSh() { delete(expression_1); delete(expression_2); }

void ERSh::accept(Visitor *v) { v->visitERSh(this); }
ERSh *ERSh::clone() const {
  return new ERSh(*this);
}

/********************   ELT    ********************/
ELT::ELT(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
ELT::ELT(const ELT & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
ELT &ELT::operator=(const ELT & other) {
  ELT tmp(other);
  swap(tmp);
  return *this;
}
void ELT::swap(ELT & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

ELT::~ELT() { delete(expression_1); delete(expression_2); }

void ELT::accept(Visitor *v) { v->visitELT(this); }
ELT *ELT::clone() const {
  return new ELT(*this);
}

/********************   EGT    ********************/
EGT::EGT(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EGT::EGT(const EGT & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EGT &EGT::operator=(const EGT & other) {
  EGT tmp(other);
  swap(tmp);
  return *this;
}
void EGT::swap(EGT & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EGT::~EGT() { delete(expression_1); delete(expression_2); }

void EGT::accept(Visitor *v) { v->visitEGT(this); }
EGT *EGT::clone() const {
  return new EGT(*this);
}

/********************   ELE    ********************/
ELE::ELE(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
ELE::ELE(const ELE & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
ELE &ELE::operator=(const ELE & other) {
  ELE tmp(other);
  swap(tmp);
  return *this;
}
void ELE::swap(ELE & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

ELE::~ELE() { delete(expression_1); delete(expression_2); }

void ELE::accept(Visitor *v) { v->visitELE(this); }
ELE *ELE::clone() const {
  return new ELE(*this);
}

/********************   EGE    ********************/
EGE::EGE(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EGE::EGE(const EGE & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EGE &EGE::operator=(const EGE & other) {
  EGE tmp(other);
  swap(tmp);
  return *this;
}
void EGE::swap(EGE & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EGE::~EGE() { delete(expression_1); delete(expression_2); }

void EGE::accept(Visitor *v) { v->visitEGE(this); }
EGE *EGE::clone() const {
  return new EGE(*this);
}

/********************   EE    ********************/
EE::EE(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EE::EE(const EE & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EE &EE::operator=(const EE & other) {
  EE tmp(other);
  swap(tmp);
  return *this;
}
void EE::swap(EE & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EE::~EE() { delete(expression_1); delete(expression_2); }

void EE::accept(Visitor *v) { v->visitEE(this); }
EE *EE::clone() const {
  return new EE(*this);
}

/********************   ENE    ********************/
ENE::ENE(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
ENE::ENE(const ENE & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
ENE &ENE::operator=(const ENE & other) {
  ENE tmp(other);
  swap(tmp);
  return *this;
}
void ENE::swap(ENE & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

ENE::~ENE() { delete(expression_1); delete(expression_2); }

void ENE::accept(Visitor *v) { v->visitENE(this); }
ENE *ENE::clone() const {
  return new ENE(*this);
}

/********************   EBand    ********************/
EBand::EBand(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EBand::EBand(const EBand & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EBand &EBand::operator=(const EBand & other) {
  EBand tmp(other);
  swap(tmp);
  return *this;
}
void EBand::swap(EBand & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EBand::~EBand() { delete(expression_1); delete(expression_2); }

void EBand::accept(Visitor *v) { v->visitEBand(this); }
EBand *EBand::clone() const {
  return new EBand(*this);
}

/********************   EBor    ********************/
EBor::EBor(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EBor::EBor(const EBor & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EBor &EBor::operator=(const EBor & other) {
  EBor tmp(other);
  swap(tmp);
  return *this;
}
void EBor::swap(EBor & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EBor::~EBor() { delete(expression_1); delete(expression_2); }

void EBor::accept(Visitor *v) { v->visitEBor(this); }
EBor *EBor::clone() const {
  return new EBor(*this);
}

/********************   EBxor    ********************/
EBxor::EBxor(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
EBxor::EBxor(const EBxor & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
EBxor &EBxor::operator=(const EBxor & other) {
  EBxor tmp(other);
  swap(tmp);
  return *this;
}
void EBxor::swap(EBxor & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EBxor::~EBxor() { delete(expression_1); delete(expression_2); }

void EBxor::accept(Visitor *v) { v->visitEBxor(this); }
EBxor *EBxor::clone() const {
  return new EBxor(*this);
}

/********************   ELand    ********************/
ELand::ELand(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
ELand::ELand(const ELand & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
ELand &ELand::operator=(const ELand & other) {
  ELand tmp(other);
  swap(tmp);
  return *this;
}
void ELand::swap(ELand & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

ELand::~ELand() { delete(expression_1); delete(expression_2); }

void ELand::accept(Visitor *v) { v->visitELand(this); }
ELand *ELand::clone() const {
  return new ELand(*this);
}

/********************   ELor    ********************/
ELor::ELor(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
ELor::ELor(const ELor & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
ELor &ELor::operator=(const ELor & other) {
  ELor tmp(other);
  swap(tmp);
  return *this;
}
void ELor::swap(ELor & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

ELor::~ELor() { delete(expression_1); delete(expression_2); }

void ELor::accept(Visitor *v) { v->visitELor(this); }
ELor *ELor::clone() const {
  return new ELor(*this);
}

/********************   ELxor    ********************/
ELxor::ELxor(Expression *p1, Expression *p2) { expression_1 = p1; expression_2 = p2; }
ELxor::ELxor(const ELxor & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}
ELxor &ELxor::operator=(const ELxor & other) {
  ELxor tmp(other);
  swap(tmp);
  return *this;
}
void ELxor::swap(ELxor & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

ELxor::~ELxor() { delete(expression_1); delete(expression_2); }

void ELxor::accept(Visitor *v) { v->visitELxor(this); }
ELxor *ELxor::clone() const {
  return new ELxor(*this);
}

/********************   ECon    ********************/
ECon::ECon(Expression *p1, Expression *p2, Expression *p3) { expression_1 = p1; expression_2 = p2; expression_3 = p3; }
ECon::ECon(const ECon & other) {   expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();
  expression_3 = other.expression_3->clone();

}
ECon &ECon::operator=(const ECon & other) {
  ECon tmp(other);
  swap(tmp);
  return *this;
}
void ECon::swap(ECon & other) {
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);
  std::swap(expression_3, other.expression_3);

}

ECon::~ECon() { delete(expression_1); delete(expression_2); delete(expression_3); }

void ECon::accept(Visitor *v) { v->visitECon(this); }
ECon *ECon::clone() const {
  return new ECon(*this);
}

/********************   EAss    ********************/
EAss::EAss(Ident p1, Expression *p2) { ident_ = p1; expression_ = p2; }
EAss::EAss(const EAss & other) {   ident_ = other.ident_;
  expression_ = other.expression_->clone();

}
EAss &EAss::operator=(const EAss & other) {
  EAss tmp(other);
  swap(tmp);
  return *this;
}
void EAss::swap(EAss & other) {
  std::swap(ident_, other.ident_);
  std::swap(expression_, other.expression_);

}

EAss::~EAss() { delete(expression_); }

void EAss::accept(Visitor *v) { v->visitEAss(this); }
EAss *EAss::clone() const {
  return new EAss(*this);
}

/********************   EAddAss    ********************/
EAddAss::EAddAss(Ident p1, Expression *p2) { ident_ = p1; expression_ = p2; }
EAddAss::EAddAss(const EAddAss & other) {   ident_ = other.ident_;
  expression_ = other.expression_->clone();

}
EAddAss &EAddAss::operator=(const EAddAss & other) {
  EAddAss tmp(other);
  swap(tmp);
  return *this;
}
void EAddAss::swap(EAddAss & other) {
  std::swap(ident_, other.ident_);
  std::swap(expression_, other.expression_);

}

EAddAss::~EAddAss() { delete(expression_); }

void EAddAss::accept(Visitor *v) { v->visitEAddAss(this); }
EAddAss *EAddAss::clone() const {
  return new EAddAss(*this);
}

/********************   ESubAss    ********************/
ESubAss::ESubAss(Ident p1, Expression *p2) { ident_ = p1; expression_ = p2; }
ESubAss::ESubAss(const ESubAss & other) {   ident_ = other.ident_;
  expression_ = other.expression_->clone();

}
ESubAss &ESubAss::operator=(const ESubAss & other) {
  ESubAss tmp(other);
  swap(tmp);
  return *this;
}
void ESubAss::swap(ESubAss & other) {
  std::swap(ident_, other.ident_);
  std::swap(expression_, other.expression_);

}

ESubAss::~ESubAss() { delete(expression_); }

void ESubAss::accept(Visitor *v) { v->visitESubAss(this); }
ESubAss *ESubAss::clone() const {
  return new ESubAss(*this);
}

/********************   EMulAss    ********************/
EMulAss::EMulAss(Ident p1, Expression *p2) { ident_ = p1; expression_ = p2; }
EMulAss::EMulAss(const EMulAss & other) {   ident_ = other.ident_;
  expression_ = other.expression_->clone();

}
EMulAss &EMulAss::operator=(const EMulAss & other) {
  EMulAss tmp(other);
  swap(tmp);
  return *this;
}
void EMulAss::swap(EMulAss & other) {
  std::swap(ident_, other.ident_);
  std::swap(expression_, other.expression_);

}

EMulAss::~EMulAss() { delete(expression_); }

void EMulAss::accept(Visitor *v) { v->visitEMulAss(this); }
EMulAss *EMulAss::clone() const {
  return new EMulAss(*this);
}

/********************   EDivAss    ********************/
EDivAss::EDivAss(Ident p1, Expression *p2) { ident_ = p1; expression_ = p2; }
EDivAss::EDivAss(const EDivAss & other) {   ident_ = other.ident_;
  expression_ = other.expression_->clone();

}
EDivAss &EDivAss::operator=(const EDivAss & other) {
  EDivAss tmp(other);
  swap(tmp);
  return *this;
}
void EDivAss::swap(EDivAss & other) {
  std::swap(ident_, other.ident_);
  std::swap(expression_, other.expression_);

}

EDivAss::~EDivAss() { delete(expression_); }

void EDivAss::accept(Visitor *v) { v->visitEDivAss(this); }
EDivAss *EDivAss::clone() const {
  return new EDivAss(*this);
}

/********************   EModAss    ********************/
EModAss::EModAss(Ident p1, Expression *p2) { ident_ = p1; expression_ = p2; }
EModAss::EModAss(const EModAss & other) {   ident_ = other.ident_;
  expression_ = other.expression_->clone();

}
EModAss &EModAss::operator=(const EModAss & other) {
  EModAss tmp(other);
  swap(tmp);
  return *this;
}
void EModAss::swap(EModAss & other) {
  std::swap(ident_, other.ident_);
  std::swap(expression_, other.expression_);

}

EModAss::~EModAss() { delete(expression_); }

void EModAss::accept(Visitor *v) { v->visitEModAss(this); }
EModAss *EModAss::clone() const {
  return new EModAss(*this);
}

/********************   EAndAss    ********************/
EAndAss::EAndAss(Ident p1, Expression *p2) { ident_ = p1; expression_ = p2; }
EAndAss::EAndAss(const EAndAss & other) {   ident_ = other.ident_;
  expression_ = other.expression_->clone();

}
EAndAss &EAndAss::operator=(const EAndAss & other) {
  EAndAss tmp(other);
  swap(tmp);
  return *this;
}
void EAndAss::swap(EAndAss & other) {
  std::swap(ident_, other.ident_);
  std::swap(expression_, other.expression_);

}

EAndAss::~EAndAss() { delete(expression_); }

void EAndAss::accept(Visitor *v) { v->visitEAndAss(this); }
EAndAss *EAndAss::clone() const {
  return new EAndAss(*this);
}

/********************   EOrAss    ********************/
EOrAss::EOrAss(Ident p1, Expression *p2) { ident_ = p1; expression_ = p2; }
EOrAss::EOrAss(const EOrAss & other) {   ident_ = other.ident_;
  expression_ = other.expression_->clone();

}
EOrAss &EOrAss::operator=(const EOrAss & other) {
  EOrAss tmp(other);
  swap(tmp);
  return *this;
}
void EOrAss::swap(EOrAss & other) {
  std::swap(ident_, other.ident_);
  std::swap(expression_, other.expression_);

}

EOrAss::~EOrAss() { delete(expression_); }

void EOrAss::accept(Visitor *v) { v->visitEOrAss(this); }
EOrAss *EOrAss::clone() const {
  return new EOrAss(*this);
}

/********************   EXorAss    ********************/
EXorAss::EXorAss(Ident p1, Expression *p2) { ident_ = p1; expression_ = p2; }
EXorAss::EXorAss(const EXorAss & other) {   ident_ = other.ident_;
  expression_ = other.expression_->clone();

}
EXorAss &EXorAss::operator=(const EXorAss & other) {
  EXorAss tmp(other);
  swap(tmp);
  return *this;
}
void EXorAss::swap(EXorAss & other) {
  std::swap(ident_, other.ident_);
  std::swap(expression_, other.expression_);

}

EXorAss::~EXorAss() { delete(expression_); }

void EXorAss::accept(Visitor *v) { v->visitEXorAss(this); }
EXorAss *EXorAss::clone() const {
  return new EXorAss(*this);
}

/********************   ELShAss    ********************/
ELShAss::ELShAss(Ident p1, Expression *p2) { ident_ = p1; expression_ = p2; }
ELShAss::ELShAss(const ELShAss & other) {   ident_ = other.ident_;
  expression_ = other.expression_->clone();

}
ELShAss &ELShAss::operator=(const ELShAss & other) {
  ELShAss tmp(other);
  swap(tmp);
  return *this;
}
void ELShAss::swap(ELShAss & other) {
  std::swap(ident_, other.ident_);
  std::swap(expression_, other.expression_);

}

ELShAss::~ELShAss() { delete(expression_); }

void ELShAss::accept(Visitor *v) { v->visitELShAss(this); }
ELShAss *ELShAss::clone() const {
  return new ELShAss(*this);
}

/********************   ERShAss    ********************/
ERShAss::ERShAss(Ident p1, Expression *p2) { ident_ = p1; expression_ = p2; }
ERShAss::ERShAss(const ERShAss & other) {   ident_ = other.ident_;
  expression_ = other.expression_->clone();

}
ERShAss &ERShAss::operator=(const ERShAss & other) {
  ERShAss tmp(other);
  swap(tmp);
  return *this;
}
void ERShAss::swap(ERShAss & other) {
  std::swap(ident_, other.ident_);
  std::swap(expression_, other.expression_);

}

ERShAss::~ERShAss() { delete(expression_); }

void ERShAss::accept(Visitor *v) { v->visitERShAss(this); }
ERShAss *ERShAss::clone() const {
  return new ERShAss(*this);
}

/********************   ListExpression    ********************/
ListExpression::ListExpression(Expression *p1, ListExpression *p2) { expression_ = p1; listexpression_ = p2; }
ListExpression::ListExpression(const ListExpression & other) {   expression_ = other.expression_->clone();
  listexpression_ = other.listexpression_->clone();

}
ListExpression &ListExpression::operator=(const ListExpression & other) {
  ListExpression tmp(other);
  swap(tmp);
  return *this;
}
void ListExpression::swap(ListExpression & other) {
  std::swap(expression_, other.expression_);
  std::swap(listexpression_, other.listexpression_);

}

ListExpression::~ListExpression() { delete(expression_); delete(listexpression_); }
ListExpression::ListExpression(Expression *p)
{
  expression_ = p;
  listexpression_= 0;
}
ListExpression* ListExpression::reverse()
{
  if (listexpression_ == 0) return this;
  else
  {
    ListExpression *tmp = listexpression_->reverse(this);
    listexpression_ = 0;
    return tmp;
  }
}

ListExpression* ListExpression::reverse(ListExpression* prev)
{
  if (listexpression_ == 0)
  {
    listexpression_ = prev;
    return this;
  }
  else
  {
    ListExpression *tmp = listexpression_->reverse(this);
    listexpression_ = prev;
    return tmp;
  }
}


void ListExpression::accept(Visitor *v) { v->visitListExpression(this); }
ListExpression *ListExpression::clone() const {
  return new ListExpression(*this);
}


