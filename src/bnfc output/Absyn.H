#ifndef ABSYN_HEADER
#define ABSYN_HEADER

//C++ Abstract Syntax Interface generated by the BNF Converter.

/********************   TypeDef Section    ********************/
typedef int Integer;
typedef char Char;
typedef double Double;
typedef char* String;
typedef char* Ident;


/********************   Forward Declarations    ********************/

class Main;
class BFunc;
class BStmt;
class DTFunc;
class DTParam;
class ListBlock;
class ListFunction;
class ListStatement;
class ListParameter;
class SExp;
class SScope;
class SRet;
class SIf;
class SIfElse;
class SWhile;
class SUntil;
class SFor;
class SBreak;
class SContinue;
class ECDbl;
class ECInt;
class EVar;
class EPi;
class ESimpleCall;
class ECall;
class EPostInc;
class EPostDec;
class EAbs;
class EPow;
class ESqrt;
class EExp;
class ELog;
class ELogD;
class ESin;
class ECos;
class ETan;
class EAtan;
class EAtanT;
class EAsin;
class EAcos;
class ELnot;
class EPreInc;
class EPreDec;
class ENeg;
class EBnot;
class EPos;
class EMul;
class EDiv;
class EMod;
class EAdd;
class ESub;
class ELSh;
class ERSh;
class ELT;
class EGT;
class ELE;
class EGE;
class EE;
class ENE;
class EBand;
class EBor;
class EBxor;
class ELand;
class ELor;
class ELxor;
class ECon;
class EAss;
class EAddAss;
class ESubAss;
class EMulAss;
class EDivAss;
class EModAss;
class EAndAss;
class EOrAss;
class EXorAss;
class ELShAss;
class ERShAss;
class ListExpression;
class Program;
class Block;
class Function;
class Parameter;
class Statement;
class Expression;


/********************   Visitor Interfaces    ********************/

class Visitor
{
 public:
  virtual ~Visitor() {}
  virtual void visitMain(Main *p) = 0;
  virtual void visitBFunc(BFunc *p) = 0;
  virtual void visitBStmt(BStmt *p) = 0;
  virtual void visitDTFunc(DTFunc *p) = 0;
  virtual void visitDTParam(DTParam *p) = 0;
  virtual void visitListBlock(ListBlock *p) = 0;
  virtual void visitListFunction(ListFunction *p) = 0;
  virtual void visitListStatement(ListStatement *p) = 0;
  virtual void visitListParameter(ListParameter *p) = 0;
  virtual void visitSExp(SExp *p) = 0;
  virtual void visitSScope(SScope *p) = 0;
  virtual void visitSRet(SRet *p) = 0;
  virtual void visitSIf(SIf *p) = 0;
  virtual void visitSIfElse(SIfElse *p) = 0;
  virtual void visitSWhile(SWhile *p) = 0;
  virtual void visitSUntil(SUntil *p) = 0;
  virtual void visitSFor(SFor *p) = 0;
  virtual void visitSBreak(SBreak *p) = 0;
  virtual void visitSContinue(SContinue *p) = 0;
  virtual void visitECDbl(ECDbl *p) = 0;
  virtual void visitECInt(ECInt *p) = 0;
  virtual void visitEVar(EVar *p) = 0;
  virtual void visitEPi(EPi *p) = 0;
  virtual void visitESimpleCall(ESimpleCall *p) = 0;
  virtual void visitECall(ECall *p) = 0;
  virtual void visitEPostInc(EPostInc *p) = 0;
  virtual void visitEPostDec(EPostDec *p) = 0;
  virtual void visitEAbs(EAbs *p) = 0;
  virtual void visitEPow(EPow *p) = 0;
  virtual void visitESqrt(ESqrt *p) = 0;
  virtual void visitEExp(EExp *p) = 0;
  virtual void visitELog(ELog *p) = 0;
  virtual void visitELogD(ELogD *p) = 0;
  virtual void visitESin(ESin *p) = 0;
  virtual void visitECos(ECos *p) = 0;
  virtual void visitETan(ETan *p) = 0;
  virtual void visitEAtan(EAtan *p) = 0;
  virtual void visitEAtanT(EAtanT *p) = 0;
  virtual void visitEAsin(EAsin *p) = 0;
  virtual void visitEAcos(EAcos *p) = 0;
  virtual void visitELnot(ELnot *p) = 0;
  virtual void visitEPreInc(EPreInc *p) = 0;
  virtual void visitEPreDec(EPreDec *p) = 0;
  virtual void visitENeg(ENeg *p) = 0;
  virtual void visitEBnot(EBnot *p) = 0;
  virtual void visitEPos(EPos *p) = 0;
  virtual void visitEMul(EMul *p) = 0;
  virtual void visitEDiv(EDiv *p) = 0;
  virtual void visitEMod(EMod *p) = 0;
  virtual void visitEAdd(EAdd *p) = 0;
  virtual void visitESub(ESub *p) = 0;
  virtual void visitELSh(ELSh *p) = 0;
  virtual void visitERSh(ERSh *p) = 0;
  virtual void visitELT(ELT *p) = 0;
  virtual void visitEGT(EGT *p) = 0;
  virtual void visitELE(ELE *p) = 0;
  virtual void visitEGE(EGE *p) = 0;
  virtual void visitEE(EE *p) = 0;
  virtual void visitENE(ENE *p) = 0;
  virtual void visitEBand(EBand *p) = 0;
  virtual void visitEBor(EBor *p) = 0;
  virtual void visitEBxor(EBxor *p) = 0;
  virtual void visitELand(ELand *p) = 0;
  virtual void visitELor(ELor *p) = 0;
  virtual void visitELxor(ELxor *p) = 0;
  virtual void visitECon(ECon *p) = 0;
  virtual void visitEAss(EAss *p) = 0;
  virtual void visitEAddAss(EAddAss *p) = 0;
  virtual void visitESubAss(ESubAss *p) = 0;
  virtual void visitEMulAss(EMulAss *p) = 0;
  virtual void visitEDivAss(EDivAss *p) = 0;
  virtual void visitEModAss(EModAss *p) = 0;
  virtual void visitEAndAss(EAndAss *p) = 0;
  virtual void visitEOrAss(EOrAss *p) = 0;
  virtual void visitEXorAss(EXorAss *p) = 0;
  virtual void visitELShAss(ELShAss *p) = 0;
  virtual void visitERShAss(ERShAss *p) = 0;
  virtual void visitListExpression(ListExpression *p) = 0;
  virtual void visitProgram(Program *p) = 0;
  virtual void visitBlock(Block *p) = 0;
  virtual void visitFunction(Function *p) = 0;
  virtual void visitParameter(Parameter *p) = 0;
  virtual void visitStatement(Statement *p) = 0;
  virtual void visitExpression(Expression *p) = 0;

  virtual void visitInteger(Integer i) = 0;
  virtual void visitDouble(Double d) = 0;
  virtual void visitChar(Char c) = 0;
  virtual void visitString(String s) = 0;
};


class Visitable
{
 public:
  virtual ~Visitable() {}
  virtual void accept(Visitor *v) = 0;
};



/********************   Abstract Syntax Classes    ********************/

class Program : public Visitable {
public:
  virtual Program *clone() const = 0;
};

class Main : public Program
{
 public:
  ListBlock *listblock_;

  Main(const Main &);
  Main &operator=(const Main &);
  Main(ListBlock *p1);
  ~Main();
  virtual void accept(Visitor *v);
  virtual  Main  *clone() const;
  void swap(Main &);
};


class Block : public Visitable {
public:
  virtual Block *clone() const = 0;
};

class BFunc : public Block
{
 public:
  ListFunction *listfunction_;

  BFunc(const BFunc &);
  BFunc &operator=(const BFunc &);
  BFunc(ListFunction *p1);
  ~BFunc();
  virtual void accept(Visitor *v);
  virtual  BFunc  *clone() const;
  void swap(BFunc &);
};

class BStmt : public Block
{
 public:
  ListStatement *liststatement_;

  BStmt(const BStmt &);
  BStmt &operator=(const BStmt &);
  BStmt(ListStatement *p1);
  ~BStmt();
  virtual void accept(Visitor *v);
  virtual  BStmt  *clone() const;
  void swap(BStmt &);
};


class Function : public Visitable {
public:
  virtual Function *clone() const = 0;
};

class DTFunc : public Function
{
 public:
  Ident ident_;
  ListParameter *listparameter_;
  ListBlock *listblock_;

  DTFunc(const DTFunc &);
  DTFunc &operator=(const DTFunc &);
  DTFunc(Ident p1, ListParameter *p2, ListBlock *p3);
  ~DTFunc();
  virtual void accept(Visitor *v);
  virtual  DTFunc  *clone() const;
  void swap(DTFunc &);
};


class Parameter : public Visitable {
public:
  virtual Parameter *clone() const = 0;
};

class DTParam : public Parameter
{
 public:
  Ident ident_;

  DTParam(const DTParam &);
  DTParam &operator=(const DTParam &);
  DTParam(Ident p1);
  ~DTParam();
  virtual void accept(Visitor *v);
  virtual  DTParam  *clone() const;
  void swap(DTParam &);
};


class ListBlock : public Visitable
{
 public:
  Block *block_;
  ListBlock *listblock_;

  ListBlock(const ListBlock &);
  ListBlock &operator=(const ListBlock &);
  ListBlock(Block *p1, ListBlock *p2);
  ListBlock(Block *p);
  ~ListBlock();
  ListBlock* reverse();
  ListBlock* reverse(ListBlock *l);
  virtual void accept(Visitor *v);
  virtual ListBlock *clone() const;
  void swap(ListBlock &);
};
class ListFunction : public Visitable
{
 public:
  Function *function_;
  ListFunction *listfunction_;

  ListFunction(const ListFunction &);
  ListFunction &operator=(const ListFunction &);
  ListFunction(Function *p1, ListFunction *p2);
  ListFunction(Function *p);
  ~ListFunction();
  ListFunction* reverse();
  ListFunction* reverse(ListFunction *l);
  virtual void accept(Visitor *v);
  virtual ListFunction *clone() const;
  void swap(ListFunction &);
};
class ListStatement : public Visitable
{
 public:
  Statement *statement_;
  ListStatement *liststatement_;

  ListStatement(const ListStatement &);
  ListStatement &operator=(const ListStatement &);
  ListStatement(Statement *p1, ListStatement *p2);
  ListStatement(Statement *p);
  ~ListStatement();
  ListStatement* reverse();
  ListStatement* reverse(ListStatement *l);
  virtual void accept(Visitor *v);
  virtual ListStatement *clone() const;
  void swap(ListStatement &);
};
class ListParameter : public Visitable
{
 public:
  Parameter *parameter_;
  ListParameter *listparameter_;

  ListParameter(const ListParameter &);
  ListParameter &operator=(const ListParameter &);
  ListParameter(Parameter *p1, ListParameter *p2);
  ListParameter(Parameter *p);
  ~ListParameter();
  ListParameter* reverse();
  ListParameter* reverse(ListParameter *l);
  virtual void accept(Visitor *v);
  virtual ListParameter *clone() const;
  void swap(ListParameter &);
};
class Statement : public Visitable {
public:
  virtual Statement *clone() const = 0;
};

class SExp : public Statement
{
 public:
  Expression *expression_;

  SExp(const SExp &);
  SExp &operator=(const SExp &);
  SExp(Expression *p1);
  ~SExp();
  virtual void accept(Visitor *v);
  virtual  SExp  *clone() const;
  void swap(SExp &);
};

class SScope : public Statement
{
 public:
  ListStatement *liststatement_;

  SScope(const SScope &);
  SScope &operator=(const SScope &);
  SScope(ListStatement *p1);
  ~SScope();
  virtual void accept(Visitor *v);
  virtual  SScope  *clone() const;
  void swap(SScope &);
};

class SRet : public Statement
{
 public:
  Expression *expression_;

  SRet(const SRet &);
  SRet &operator=(const SRet &);
  SRet(Expression *p1);
  ~SRet();
  virtual void accept(Visitor *v);
  virtual  SRet  *clone() const;
  void swap(SRet &);
};

class SIf : public Statement
{
 public:
  Expression *expression_;
  Statement *statement_;

  SIf(const SIf &);
  SIf &operator=(const SIf &);
  SIf(Expression *p1, Statement *p2);
  ~SIf();
  virtual void accept(Visitor *v);
  virtual  SIf  *clone() const;
  void swap(SIf &);
};

class SIfElse : public Statement
{
 public:
  Expression *expression_;
  Statement *statement_1, *statement_2;

  SIfElse(const SIfElse &);
  SIfElse &operator=(const SIfElse &);
  SIfElse(Expression *p1, Statement *p2, Statement *p3);
  ~SIfElse();
  virtual void accept(Visitor *v);
  virtual  SIfElse  *clone() const;
  void swap(SIfElse &);
};

class SWhile : public Statement
{
 public:
  Expression *expression_;
  Statement *statement_;

  SWhile(const SWhile &);
  SWhile &operator=(const SWhile &);
  SWhile(Expression *p1, Statement *p2);
  ~SWhile();
  virtual void accept(Visitor *v);
  virtual  SWhile  *clone() const;
  void swap(SWhile &);
};

class SUntil : public Statement
{
 public:
  Expression *expression_;
  Statement *statement_;

  SUntil(const SUntil &);
  SUntil &operator=(const SUntil &);
  SUntil(Expression *p1, Statement *p2);
  ~SUntil();
  virtual void accept(Visitor *v);
  virtual  SUntil  *clone() const;
  void swap(SUntil &);
};

class SFor : public Statement
{
 public:
  ListExpression *listexpression_1, *listexpression_2;
  Expression *expression_;
  Statement *statement_;

  SFor(const SFor &);
  SFor &operator=(const SFor &);
  SFor(ListExpression *p1, Expression *p2, ListExpression *p3, Statement *p4);
  ~SFor();
  virtual void accept(Visitor *v);
  virtual  SFor  *clone() const;
  void swap(SFor &);
};

class SBreak : public Statement
{
 public:

  SBreak(const SBreak &);
  SBreak &operator=(const SBreak &);
  SBreak();
  ~SBreak();
  virtual void accept(Visitor *v);
  virtual  SBreak  *clone() const;
  void swap(SBreak &);
};

class SContinue : public Statement
{
 public:

  SContinue(const SContinue &);
  SContinue &operator=(const SContinue &);
  SContinue();
  ~SContinue();
  virtual void accept(Visitor *v);
  virtual  SContinue  *clone() const;
  void swap(SContinue &);
};


class Expression : public Visitable {
public:
  virtual Expression *clone() const = 0;
};

class ECDbl : public Expression
{
 public:
  Double double_;

  ECDbl(const ECDbl &);
  ECDbl &operator=(const ECDbl &);
  ECDbl(Double p1);
  ~ECDbl();
  virtual void accept(Visitor *v);
  virtual  ECDbl  *clone() const;
  void swap(ECDbl &);
};

class ECInt : public Expression
{
 public:
  Integer integer_;

  ECInt(const ECInt &);
  ECInt &operator=(const ECInt &);
  ECInt(Integer p1);
  ~ECInt();
  virtual void accept(Visitor *v);
  virtual  ECInt  *clone() const;
  void swap(ECInt &);
};

class EVar : public Expression
{
 public:
  Ident ident_;

  EVar(const EVar &);
  EVar &operator=(const EVar &);
  EVar(Ident p1);
  ~EVar();
  virtual void accept(Visitor *v);
  virtual  EVar  *clone() const;
  void swap(EVar &);
};

class EPi : public Expression
{
 public:

  EPi(const EPi &);
  EPi &operator=(const EPi &);
  EPi();
  ~EPi();
  virtual void accept(Visitor *v);
  virtual  EPi  *clone() const;
  void swap(EPi &);
};

class ESimpleCall : public Expression
{
 public:
  Ident ident_;

  ESimpleCall(const ESimpleCall &);
  ESimpleCall &operator=(const ESimpleCall &);
  ESimpleCall(Ident p1);
  ~ESimpleCall();
  virtual void accept(Visitor *v);
  virtual  ESimpleCall  *clone() const;
  void swap(ESimpleCall &);
};

class ECall : public Expression
{
 public:
  Ident ident_;
  ListExpression *listexpression_;

  ECall(const ECall &);
  ECall &operator=(const ECall &);
  ECall(Ident p1, ListExpression *p2);
  ~ECall();
  virtual void accept(Visitor *v);
  virtual  ECall  *clone() const;
  void swap(ECall &);
};

class EPostInc : public Expression
{
 public:
  Ident ident_;

  EPostInc(const EPostInc &);
  EPostInc &operator=(const EPostInc &);
  EPostInc(Ident p1);
  ~EPostInc();
  virtual void accept(Visitor *v);
  virtual  EPostInc  *clone() const;
  void swap(EPostInc &);
};

class EPostDec : public Expression
{
 public:
  Ident ident_;

  EPostDec(const EPostDec &);
  EPostDec &operator=(const EPostDec &);
  EPostDec(Ident p1);
  ~EPostDec();
  virtual void accept(Visitor *v);
  virtual  EPostDec  *clone() const;
  void swap(EPostDec &);
};

class EAbs : public Expression
{
 public:
  Expression *expression_;

  EAbs(const EAbs &);
  EAbs &operator=(const EAbs &);
  EAbs(Expression *p1);
  ~EAbs();
  virtual void accept(Visitor *v);
  virtual  EAbs  *clone() const;
  void swap(EAbs &);
};

class EPow : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EPow(const EPow &);
  EPow &operator=(const EPow &);
  EPow(Expression *p1, Expression *p2);
  ~EPow();
  virtual void accept(Visitor *v);
  virtual  EPow  *clone() const;
  void swap(EPow &);
};

class ESqrt : public Expression
{
 public:
  Expression *expression_;

  ESqrt(const ESqrt &);
  ESqrt &operator=(const ESqrt &);
  ESqrt(Expression *p1);
  ~ESqrt();
  virtual void accept(Visitor *v);
  virtual  ESqrt  *clone() const;
  void swap(ESqrt &);
};

class EExp : public Expression
{
 public:
  Expression *expression_;

  EExp(const EExp &);
  EExp &operator=(const EExp &);
  EExp(Expression *p1);
  ~EExp();
  virtual void accept(Visitor *v);
  virtual  EExp  *clone() const;
  void swap(EExp &);
};

class ELog : public Expression
{
 public:
  Expression *expression_;

  ELog(const ELog &);
  ELog &operator=(const ELog &);
  ELog(Expression *p1);
  ~ELog();
  virtual void accept(Visitor *v);
  virtual  ELog  *clone() const;
  void swap(ELog &);
};

class ELogD : public Expression
{
 public:
  Expression *expression_;

  ELogD(const ELogD &);
  ELogD &operator=(const ELogD &);
  ELogD(Expression *p1);
  ~ELogD();
  virtual void accept(Visitor *v);
  virtual  ELogD  *clone() const;
  void swap(ELogD &);
};

class ESin : public Expression
{
 public:
  Expression *expression_;

  ESin(const ESin &);
  ESin &operator=(const ESin &);
  ESin(Expression *p1);
  ~ESin();
  virtual void accept(Visitor *v);
  virtual  ESin  *clone() const;
  void swap(ESin &);
};

class ECos : public Expression
{
 public:
  Expression *expression_;

  ECos(const ECos &);
  ECos &operator=(const ECos &);
  ECos(Expression *p1);
  ~ECos();
  virtual void accept(Visitor *v);
  virtual  ECos  *clone() const;
  void swap(ECos &);
};

class ETan : public Expression
{
 public:
  Expression *expression_;

  ETan(const ETan &);
  ETan &operator=(const ETan &);
  ETan(Expression *p1);
  ~ETan();
  virtual void accept(Visitor *v);
  virtual  ETan  *clone() const;
  void swap(ETan &);
};

class EAtan : public Expression
{
 public:
  Expression *expression_;

  EAtan(const EAtan &);
  EAtan &operator=(const EAtan &);
  EAtan(Expression *p1);
  ~EAtan();
  virtual void accept(Visitor *v);
  virtual  EAtan  *clone() const;
  void swap(EAtan &);
};

class EAtanT : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EAtanT(const EAtanT &);
  EAtanT &operator=(const EAtanT &);
  EAtanT(Expression *p1, Expression *p2);
  ~EAtanT();
  virtual void accept(Visitor *v);
  virtual  EAtanT  *clone() const;
  void swap(EAtanT &);
};

class EAsin : public Expression
{
 public:
  Expression *expression_;

  EAsin(const EAsin &);
  EAsin &operator=(const EAsin &);
  EAsin(Expression *p1);
  ~EAsin();
  virtual void accept(Visitor *v);
  virtual  EAsin  *clone() const;
  void swap(EAsin &);
};

class EAcos : public Expression
{
 public:
  Expression *expression_;

  EAcos(const EAcos &);
  EAcos &operator=(const EAcos &);
  EAcos(Expression *p1);
  ~EAcos();
  virtual void accept(Visitor *v);
  virtual  EAcos  *clone() const;
  void swap(EAcos &);
};

class ELnot : public Expression
{
 public:
  Expression *expression_;

  ELnot(const ELnot &);
  ELnot &operator=(const ELnot &);
  ELnot(Expression *p1);
  ~ELnot();
  virtual void accept(Visitor *v);
  virtual  ELnot  *clone() const;
  void swap(ELnot &);
};

class EPreInc : public Expression
{
 public:
  Ident ident_;

  EPreInc(const EPreInc &);
  EPreInc &operator=(const EPreInc &);
  EPreInc(Ident p1);
  ~EPreInc();
  virtual void accept(Visitor *v);
  virtual  EPreInc  *clone() const;
  void swap(EPreInc &);
};

class EPreDec : public Expression
{
 public:
  Ident ident_;

  EPreDec(const EPreDec &);
  EPreDec &operator=(const EPreDec &);
  EPreDec(Ident p1);
  ~EPreDec();
  virtual void accept(Visitor *v);
  virtual  EPreDec  *clone() const;
  void swap(EPreDec &);
};

class ENeg : public Expression
{
 public:
  Expression *expression_;

  ENeg(const ENeg &);
  ENeg &operator=(const ENeg &);
  ENeg(Expression *p1);
  ~ENeg();
  virtual void accept(Visitor *v);
  virtual  ENeg  *clone() const;
  void swap(ENeg &);
};

class EBnot : public Expression
{
 public:
  Expression *expression_;

  EBnot(const EBnot &);
  EBnot &operator=(const EBnot &);
  EBnot(Expression *p1);
  ~EBnot();
  virtual void accept(Visitor *v);
  virtual  EBnot  *clone() const;
  void swap(EBnot &);
};

class EPos : public Expression
{
 public:
  Expression *expression_;

  EPos(const EPos &);
  EPos &operator=(const EPos &);
  EPos(Expression *p1);
  ~EPos();
  virtual void accept(Visitor *v);
  virtual  EPos  *clone() const;
  void swap(EPos &);
};

class EMul : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EMul(const EMul &);
  EMul &operator=(const EMul &);
  EMul(Expression *p1, Expression *p2);
  ~EMul();
  virtual void accept(Visitor *v);
  virtual  EMul  *clone() const;
  void swap(EMul &);
};

class EDiv : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EDiv(const EDiv &);
  EDiv &operator=(const EDiv &);
  EDiv(Expression *p1, Expression *p2);
  ~EDiv();
  virtual void accept(Visitor *v);
  virtual  EDiv  *clone() const;
  void swap(EDiv &);
};

class EMod : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EMod(const EMod &);
  EMod &operator=(const EMod &);
  EMod(Expression *p1, Expression *p2);
  ~EMod();
  virtual void accept(Visitor *v);
  virtual  EMod  *clone() const;
  void swap(EMod &);
};

class EAdd : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EAdd(const EAdd &);
  EAdd &operator=(const EAdd &);
  EAdd(Expression *p1, Expression *p2);
  ~EAdd();
  virtual void accept(Visitor *v);
  virtual  EAdd  *clone() const;
  void swap(EAdd &);
};

class ESub : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  ESub(const ESub &);
  ESub &operator=(const ESub &);
  ESub(Expression *p1, Expression *p2);
  ~ESub();
  virtual void accept(Visitor *v);
  virtual  ESub  *clone() const;
  void swap(ESub &);
};

class ELSh : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  ELSh(const ELSh &);
  ELSh &operator=(const ELSh &);
  ELSh(Expression *p1, Expression *p2);
  ~ELSh();
  virtual void accept(Visitor *v);
  virtual  ELSh  *clone() const;
  void swap(ELSh &);
};

class ERSh : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  ERSh(const ERSh &);
  ERSh &operator=(const ERSh &);
  ERSh(Expression *p1, Expression *p2);
  ~ERSh();
  virtual void accept(Visitor *v);
  virtual  ERSh  *clone() const;
  void swap(ERSh &);
};

class ELT : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  ELT(const ELT &);
  ELT &operator=(const ELT &);
  ELT(Expression *p1, Expression *p2);
  ~ELT();
  virtual void accept(Visitor *v);
  virtual  ELT  *clone() const;
  void swap(ELT &);
};

class EGT : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EGT(const EGT &);
  EGT &operator=(const EGT &);
  EGT(Expression *p1, Expression *p2);
  ~EGT();
  virtual void accept(Visitor *v);
  virtual  EGT  *clone() const;
  void swap(EGT &);
};

class ELE : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  ELE(const ELE &);
  ELE &operator=(const ELE &);
  ELE(Expression *p1, Expression *p2);
  ~ELE();
  virtual void accept(Visitor *v);
  virtual  ELE  *clone() const;
  void swap(ELE &);
};

class EGE : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EGE(const EGE &);
  EGE &operator=(const EGE &);
  EGE(Expression *p1, Expression *p2);
  ~EGE();
  virtual void accept(Visitor *v);
  virtual  EGE  *clone() const;
  void swap(EGE &);
};

class EE : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EE(const EE &);
  EE &operator=(const EE &);
  EE(Expression *p1, Expression *p2);
  ~EE();
  virtual void accept(Visitor *v);
  virtual  EE  *clone() const;
  void swap(EE &);
};

class ENE : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  ENE(const ENE &);
  ENE &operator=(const ENE &);
  ENE(Expression *p1, Expression *p2);
  ~ENE();
  virtual void accept(Visitor *v);
  virtual  ENE  *clone() const;
  void swap(ENE &);
};

class EBand : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EBand(const EBand &);
  EBand &operator=(const EBand &);
  EBand(Expression *p1, Expression *p2);
  ~EBand();
  virtual void accept(Visitor *v);
  virtual  EBand  *clone() const;
  void swap(EBand &);
};

class EBor : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EBor(const EBor &);
  EBor &operator=(const EBor &);
  EBor(Expression *p1, Expression *p2);
  ~EBor();
  virtual void accept(Visitor *v);
  virtual  EBor  *clone() const;
  void swap(EBor &);
};

class EBxor : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  EBxor(const EBxor &);
  EBxor &operator=(const EBxor &);
  EBxor(Expression *p1, Expression *p2);
  ~EBxor();
  virtual void accept(Visitor *v);
  virtual  EBxor  *clone() const;
  void swap(EBxor &);
};

class ELand : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  ELand(const ELand &);
  ELand &operator=(const ELand &);
  ELand(Expression *p1, Expression *p2);
  ~ELand();
  virtual void accept(Visitor *v);
  virtual  ELand  *clone() const;
  void swap(ELand &);
};

class ELor : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  ELor(const ELor &);
  ELor &operator=(const ELor &);
  ELor(Expression *p1, Expression *p2);
  ~ELor();
  virtual void accept(Visitor *v);
  virtual  ELor  *clone() const;
  void swap(ELor &);
};

class ELxor : public Expression
{
 public:
  Expression *expression_1, *expression_2;

  ELxor(const ELxor &);
  ELxor &operator=(const ELxor &);
  ELxor(Expression *p1, Expression *p2);
  ~ELxor();
  virtual void accept(Visitor *v);
  virtual  ELxor  *clone() const;
  void swap(ELxor &);
};

class ECon : public Expression
{
 public:
  Expression *expression_1, *expression_2, *expression_3;

  ECon(const ECon &);
  ECon &operator=(const ECon &);
  ECon(Expression *p1, Expression *p2, Expression *p3);
  ~ECon();
  virtual void accept(Visitor *v);
  virtual  ECon  *clone() const;
  void swap(ECon &);
};

class EAss : public Expression
{
 public:
  Ident ident_;
  Expression *expression_;

  EAss(const EAss &);
  EAss &operator=(const EAss &);
  EAss(Ident p1, Expression *p2);
  ~EAss();
  virtual void accept(Visitor *v);
  virtual  EAss  *clone() const;
  void swap(EAss &);
};

class EAddAss : public Expression
{
 public:
  Ident ident_;
  Expression *expression_;

  EAddAss(const EAddAss &);
  EAddAss &operator=(const EAddAss &);
  EAddAss(Ident p1, Expression *p2);
  ~EAddAss();
  virtual void accept(Visitor *v);
  virtual  EAddAss  *clone() const;
  void swap(EAddAss &);
};

class ESubAss : public Expression
{
 public:
  Ident ident_;
  Expression *expression_;

  ESubAss(const ESubAss &);
  ESubAss &operator=(const ESubAss &);
  ESubAss(Ident p1, Expression *p2);
  ~ESubAss();
  virtual void accept(Visitor *v);
  virtual  ESubAss  *clone() const;
  void swap(ESubAss &);
};

class EMulAss : public Expression
{
 public:
  Ident ident_;
  Expression *expression_;

  EMulAss(const EMulAss &);
  EMulAss &operator=(const EMulAss &);
  EMulAss(Ident p1, Expression *p2);
  ~EMulAss();
  virtual void accept(Visitor *v);
  virtual  EMulAss  *clone() const;
  void swap(EMulAss &);
};

class EDivAss : public Expression
{
 public:
  Ident ident_;
  Expression *expression_;

  EDivAss(const EDivAss &);
  EDivAss &operator=(const EDivAss &);
  EDivAss(Ident p1, Expression *p2);
  ~EDivAss();
  virtual void accept(Visitor *v);
  virtual  EDivAss  *clone() const;
  void swap(EDivAss &);
};

class EModAss : public Expression
{
 public:
  Ident ident_;
  Expression *expression_;

  EModAss(const EModAss &);
  EModAss &operator=(const EModAss &);
  EModAss(Ident p1, Expression *p2);
  ~EModAss();
  virtual void accept(Visitor *v);
  virtual  EModAss  *clone() const;
  void swap(EModAss &);
};

class EAndAss : public Expression
{
 public:
  Ident ident_;
  Expression *expression_;

  EAndAss(const EAndAss &);
  EAndAss &operator=(const EAndAss &);
  EAndAss(Ident p1, Expression *p2);
  ~EAndAss();
  virtual void accept(Visitor *v);
  virtual  EAndAss  *clone() const;
  void swap(EAndAss &);
};

class EOrAss : public Expression
{
 public:
  Ident ident_;
  Expression *expression_;

  EOrAss(const EOrAss &);
  EOrAss &operator=(const EOrAss &);
  EOrAss(Ident p1, Expression *p2);
  ~EOrAss();
  virtual void accept(Visitor *v);
  virtual  EOrAss  *clone() const;
  void swap(EOrAss &);
};

class EXorAss : public Expression
{
 public:
  Ident ident_;
  Expression *expression_;

  EXorAss(const EXorAss &);
  EXorAss &operator=(const EXorAss &);
  EXorAss(Ident p1, Expression *p2);
  ~EXorAss();
  virtual void accept(Visitor *v);
  virtual  EXorAss  *clone() const;
  void swap(EXorAss &);
};

class ELShAss : public Expression
{
 public:
  Ident ident_;
  Expression *expression_;

  ELShAss(const ELShAss &);
  ELShAss &operator=(const ELShAss &);
  ELShAss(Ident p1, Expression *p2);
  ~ELShAss();
  virtual void accept(Visitor *v);
  virtual  ELShAss  *clone() const;
  void swap(ELShAss &);
};

class ERShAss : public Expression
{
 public:
  Ident ident_;
  Expression *expression_;

  ERShAss(const ERShAss &);
  ERShAss &operator=(const ERShAss &);
  ERShAss(Ident p1, Expression *p2);
  ~ERShAss();
  virtual void accept(Visitor *v);
  virtual  ERShAss  *clone() const;
  void swap(ERShAss &);
};


class ListExpression : public Visitable
{
 public:
  Expression *expression_;
  ListExpression *listexpression_;

  ListExpression(const ListExpression &);
  ListExpression &operator=(const ListExpression &);
  ListExpression(Expression *p1, ListExpression *p2);
  ListExpression(Expression *p);
  ~ListExpression();
  ListExpression* reverse();
  ListExpression* reverse(ListExpression *l);
  virtual void accept(Visitor *v);
  virtual ListExpression *clone() const;
  void swap(ListExpression &);
};


#endif
